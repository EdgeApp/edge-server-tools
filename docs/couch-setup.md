# CouchDB Setup Tools

- [Basic Setup](#basic-setup)
- [Uploading Design Documents](#design-documents)
  - [makeMangoIndex](#makemangoindex)
  - [makeJsDesign](#makeJsDesign)
- [Watching Settings Documents](#watching-settings-documents)
- [Replication Setup](#replication-setup)
  - [Enabling Replication](#enabling-replication)
- [Background Tasks](#background-tasks)

The edge-server-tools package can create & maintain CouchDB databases, design documents, and replications. This maintenance can take place across multiple clusters or servers.

These tools can also watch for changes to specific synced documents, such as settings.

## Managing Credentials

First, create a `CouchPool` object holding your connections to CouchDB. For simple cases, this just takes a URL:

```js
import { connectCouch } from 'edge-server-tools'

const pool = connectCouch('http://admin:admin@localhost:5984/')
```

Or, if you want do auto-replication, you can provide a list of credentials and the name of the default cluster:

```js
const pool = connectCouch(
  // The preferred cluster to use for most tasks:
  'production',

  // All the clusters we can access:
  {
    production: {
      url: 'https://production.example.com:6984/',
      username: 'admin',
      password: 'admin',
    },
    logs: {
      url: 'https://admin:admin@logs.example.com:6984/',
    },
    backup: 'https://admin:admin@backup.example.com:6984/'
  }
)
```

This example has three clusters, named "production", "logs", and "backup". These credentials would normally be stored on disk, perhaps using [cleaner-config](https://www.npmjs.com/package/cleaner-config). The main app server would generally contain all the credentials for the system and be responsible for maintenance tasks, while secondary servers might just connect directly to their own URL's.

The `pool` object has a `default` property, which corresponds to the default cluster:

```js
const db = pool.default.use('my-db')
await db.list()
```

## Creating Databases

First, create a `DatabaseSetup` object to describe the database:

```ts
const productsSetup: DatabaseSetup = {
  name: 'products',
}
```

Next, when your application starts up, use `setupDatabase` to ensure the database exists and has the right settings:

```ts
await setupDatabase(pool, productsSetup)
```

If the pool contains credentials to multiple clusters, this will ensure that the database exists on each of them. If you only want to create this database on certain clusters, see the [Replication Setup](#replication-setup) section.

If the database needs special CouchDB settings, pass those as `DatabaseSetup.options`:

```ts
const productSetup: DatabaseSetup = {
  name: 'products',
  options: { partitioned: true },
}
```

## Uploading Design Documents

Many databases use design documents to manage indices. You can use the `DatabaseSetup.documents` property to automatically upload these documents to the database when they are missing or their contents don't match:

```ts
const productSetup: DatabaseSetup = {
  name: 'products',
  documents: {
    '_design/mango-upc': makeMangoIndex('upc', ['upc']),
  },
}
```

This example will create a document named "\_design/mango-upc". The contents will be a design document generated by the `makeMangoIndex` helper function.

### makeMangoIndex

Use this function to create Mango index design documents. The first parameter is the name of the view (CouchDB doesn't really use this anywhere), and the second parameter is an array of properties to index over, using CouchDB's [sort syntax](https://docs.couchdb.org/en/stable/api/database/find.html#sort-syntax).

```js
makeMangoIndex('createdByDate', ['created', 'date'])
```

You can pass an optional `filter` or `partitioned` flag using the final argument. Here is an example that only matches certain documents in a partition, and then sorts those by the "date" property:

```js
makeMangoIndex('newestToys', ['date'], {
  filter: { type: 'toy' },
  partitioned: true,
})
```

### makeJsDesign

This helper function creates JavaScript design documents. It takes the name of the view (which becomes part of the URL), a factory function to build the view methods, and an optional settings object:

```js
makeJsDesign(
  'justId',
  ({ emit }) => ({
    map: function (doc) {
      emit(doc._id.replace(/^.*:/, ''), null)
    },
  }),
  { partitioned: false }
)
```

This example uses JavaScript to edit the document ID, removing the partition part. The exact syntax is very important here - by destructuring the `emit` function in the factory function's parameter list, TypeScript believes that `emit` exists (inside CouchDB it's a global). Then, using the old-school `function` syntax ensures that calling `map.toString()` will generate valid JavaScript that CouchDB can understand.

Since CouchDB is old, the JavaScript code may require extra hacks to be valid. In that case, you can pass a `fixJs` function in the settings object, which can further edit the JavaScript string:

```js
makeJsDesign(
  'difference',
  ({ emit }) => ({
    map: function (doc) {
      const difference = doc.high - doc.low
      if (difference > 0) emit(doc._id, difference)
    },
    reduce: '_sum',
  }),
  {
    fixJs: (code) => code.replace(/let|const/g, 'var'),
  }
)
```

This example uses the `fixJs` option to convert "const" into "var" for the legacy JavaScript engine.

If you need access to utility functions, you can use CommonJS to inject them into the view:

```js
import { normalizeIp, parseIp } from './ip-utils'

makeJsDesign(
  'ip',
  ({ emit, require }) => ({
    map: function (doc) {
      const normalizeIp = require('views/lib/normalizeIp')
      const parseIp = require('views/lib/parseIp')
      const ip = normalizeIp(parseIp(doc.ip))
      emit([ip], null)
    },
  }),
  {
    fixJs: (code) => code.replace(/let|const/g, 'var'),
    lib: { normalizeIp, parseIp },
  }
)
```

This example inserts the `normalizeIp` and `parseIp` utility functions into the view using the `lib` option. Next, the `map` function imports them using CouchDB's global `require` function.

These library functions need to be completely standalone, and must use CouchDB's oldschool JavaScript syntax. They do pass through the `fixJs` function, if provided, which can help with syntax problems.

## Watching Settings Documents

CouchDB is a convenient place to store app settings such as API keys or tuning parameters. Doing this provides live updates, automatic replication, and a nice admin interface using Fauxton.

To watch a settings document for changes, use the `syncedDocument` helper function:

```js
const appSettings = syncedDocument('appSettings', asAppSettings)
```

The `syncedDocument` helper function takes two parameters - the name of the document and a cleaner to validate its contents.

This cleaner should be capable of handling errors gracefully, replacing invalid properties with defaults. Consider using [`asHealingObject`](./docs/as-healing-object.md) to accomplish this. That way, if the document is missing or broken, `syncedDocument` can re-build it during the sync process.

The synced document will contain default values to start (returned by the cleaner). To synchronize the actual values from the database, pass the synced document to `setupDatabase`:

```ts
const settingsSetup: DatabaseSetup = {
  name: 'settings',
  syncedDocuments: [appSettings],
}

// At app boot time:
await setupDatabase(pool, settingsSetup)
```

The `setupDatabase` will use the `pool.default` connection to perform an initial sync, ensuring the document exists. It will also watch the document for any future changes, keeping it up to date using the cleaner. The [Background Tasks](#background-tasks) section explains how to manage this background process.

To see the latest document contents, simply access the `appSettings.doc` property. You can also subscribe to changes using the `onChange` method:

```js
appSettings.onChange((newSettings) => console.log(newSettings))
```

You can also access the database's raw change feed by including an `onChange` method in the database setup object itself:

```ts
const usersSetup: DatabaseSetup = {
  name: 'users',
  onChange(change: CouchChange) {
    console.log(`Document ${change.id} updated`)
  },
}
```

## Replication Setup

The `setupDatabase` function can automatically create documents in the `_replicator` database. To do this, it needs a synced replicator setup document, which describes how the different CouchDB clusters should communicate. Here is an example replicator setup:

```json
{
  "_id": "replicators",
  "_rev": "12-6ee74490125b924e323807d9363d64a2",
  "clusters": {
    "production": {
      "exclude": ["#archived"],
      "pushTo": ["logs", "backup"]
    },
    "logs": {
      "include": ["logs-*"],
      "localOnly": ["settings"]
    },
    "backup": {}
  }
}
```

In this example, the "production" cluster has a `pushTo` list, which tells it to push changes out to the "logs" and "backup" clusters. The `setupDatabase` function will not create any replication documents on the other clusters, since they don't have `pushTo` or `pullFrom` properties.

Since the "logs" cluster has an `include` filter, the `setupDatabase` routine will only create and replicate databases with names that start with "logs-" on this cluster. Clusters can also specify an `exclude` filter to avoid creating specific databases, and a `localOnly` filter to create databases but not replicate them. Databases can also have tags, such as "#archived" or "#secret", which also apply to the replicator filters.

### Enabling Replication

To enable replication, you first need to create a settings database and put a replicator settings document inside. That way, editing the document will live-update the replicators database, without needing to restart the app. The following code snippet will configure this:

```ts
import {
  asReplicatorSetupDocument,
  setupDatabase,
  syncedDocument,
} from 'edge-server-tools'

export const replicatorSetup = syncedDocument(
  'replicators',
  asReplicatorSetupDocument
)

const settingsSetup: DatabaseSetup = {
  name: 'settings',
  syncedDocuments: [replicatorSetup],
}

// At app boot time:
await setupDatabase(pool, settingsSetup)
```

Finally, pass `replicatorSetup` and `currentCluster` options to the various `setupDatabase` calls in your app:

```js
const commonOptions = {
  replicatorSetup,
  // ...
}

// At app boot time:
await setupDatabase(pool, settingsSetup, commonOptions)
await setupDatabase(pool, productsSetup, commonOptions)
await setupDatabase(pool, usersSetup, commonOptions)
```

## Background Tasks

When setting up replication or synced documents, `setupDatabase` will create long-running background processes. These can interfere with CLI tools, which would like to exit quickly when they are done with their work. To avoid this problem, pass a `disableWatching` flag to `setupDatabase`:

```js
setupDatabase(pool, someSetup, {
  disableWatching: true,
})
```

The `setupDatabase` function also returns a cleanup function, which will stop all background work (eventually - it can take a while).

```js
const cleanup = setupDatabase(pool, someSetup)

// Later, at shutdown time:
cleanup()
```

The database setup process can generate errors and messages, which go to the console by default, but can be intercepted by passing `log` and `onError` options:

```ts
setupDatabase(pool, someSetup, {
  log(message: string) {
    console.log(message)
  },
  onError(error: unknown) {
    console.error(error)
  },
})
```
